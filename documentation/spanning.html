<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <title>Signs Spanning Numbers</title>
    <meta name="author" content="SIL Writing Systems Technology">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <link rel="stylesheet" href="./assets/css/theme.css">
    <link rel="stylesheet" href="./assets/css/webfonts.css">
</head>
<body>
<div class="container">
<article class="article">
    <header>
        <h1 class="title">Signs Spanning Numbers</h1>
    </header>
    <p>Some characters in Arabic script are signs that span (or enclose) numbers. Over time these have been variously called:</p>
    <ul>
    <li><em>prepended concatenation marks</em></li>
    <li><em>subtending marks</em></li>
    <li><em>prefixed format control characters</em></li>
    </ul>
    <p>For the purposes of this document, we will use the term <em>spanning signs</em> (or more simply, <em>signs</em>) to refer to these characters and <em>sign glyphs</em> for the glyphs within the font that will represent them.</p>
    <p>Since digit choice is dependent on regional use, these marks may be used with European digits (U+0030..U+0039), ARABIC-INDIC digits (U+0660..U+0669) or with EXTENDED ARABIC-INDIC digits (U+06F0..U+06F9).</p>
    <p>From a practical standpoint there isn't a need to support an arbitrary-length sequence of digits. For SIL fonts, we have found the maximum number of digits as documented in the following table to be sufficient for most uses.</p>
    <p>Examples of how these are formatted are shown below using varying number of digits with <em>hamza</em> used as a separator.</p>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: left;">Characters</th>
    <th style="text-align: right;">Glyph</th>
    <th style="text-align: left;">max # digits</th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: left;">0600 ARABIC NUMBER SIGN</td>
    <td style="text-align: right;"><span class="scheherazadenewL-R normal">ء‭؀١‬ء‭؀١٢‬ء‭؀١٢٣‬ء</span></td>
    <td style="text-align: left;">3</td>
    </tr>
    <tr class="even">
    <td style="text-align: left;">0601 ARABIC SIGN SANAH (year sign)</td>
    <td style="text-align: right;"><span class="scheherazadenewL-R normal">ء‭؁١‬ء‭؁١٢‬ء‭؁١٢٣‬ء‭؁١٢٣٤‬ء</span></td>
    <td style="text-align: left;">4</td>
    </tr>
    <tr class="odd">
    <td style="text-align: left;">0602 ARABIC FOOTNOTE MARKER</td>
    <td style="text-align: right;"><span class="scheherazadenewL-R normal">ء‭؂١‬ء‭؂١٢‬ء</span></td>
    <td style="text-align: left;">2</td>
    </tr>
    <tr class="even">
    <td style="text-align: left;">0603 ARABIC SIGN SAFHA</td>
    <td style="text-align: right;"><span class="scheherazadenewL-R normal">ء‭؃١‬ء‭؃١٢‬ء‭؃١٢٣‬ء‭؃١٢٣٤‬ء</span></td>
    <td style="text-align: left;">4</td>
    </tr>
    <tr class="odd">
    <td style="text-align: left;">0604 ARABIC SIGN SAMVAT</td>
    <td style="text-align: right;"><span class="scheherazadenewL-R normal">ء‭؄١‬ء‭؄١٢‬ء‭؄١٢٣‬ء‭؄١٢٣٤‬ء</span></td>
    <td style="text-align: left;">4</td>
    </tr>
    <tr class="even">
    <td style="text-align: left;">0605 ARABIC NUMBER MARK ABOVE</td>
    <td style="text-align: right;"><span class="scheherazadenewL-R normal">ء‭؅١‬ء‭؅١٢‬ء‭؅١٢٣‬ء‭؅١٢٣٤‬ء</span></td>
    <td style="text-align: left;">4</td>
    </tr>
    <tr class="odd">
    <td style="text-align: left;">0890 ARABIC POUND MARK ABOVE</td>
    <td style="text-align: right;"><span class="scheherazadenewL-R normal">ء‭࢐١‬ء‭࢐١٢‬ء‭࢐١٢٣‬ء‭࢐١٢٣٤‬ء</span></td>
    <td style="text-align: left;">4</td>
    </tr>
    <tr class="even">
    <td style="text-align: left;">0891 ARABIC PIASTRE MARK ABOVE</td>
    <td style="text-align: right;"><span class="scheherazadenewL-R normal">ء‭࢑١‬ء‭࢑١٢‬ء‭࢑١٢٣‬ء‭࢑١٢٣٤‬ء</span></td>
    <td style="text-align: left;">4</td>
    </tr>
    <tr class="odd">
    <td style="text-align: left;">06DD ARABIC END OF AYAH</td>
    <td style="text-align: right;"><span class="scheherazadenewL-R normal">ء‭۝١‬ء‭۝١٢‬ء‭۝١٢٣‬ء</span></td>
    <td style="text-align: left;">3</td>
    </tr>
    <tr class="even">
    <td style="text-align: left;">08E2 ARABIC DISPUTED END OF AYAH</td>
    <td style="text-align: right;"><span class="scheherazadenewL-R normal">ء‭࣢١‬ء‭࣢١٢‬ء‭࣢١٢٣‬ء</span></td>
    <td style="text-align: left;">3</td>
    </tr>
    </tbody>
    </table>
    <p>For more Unicode information about these characters, see <em>Signs Spanning Numbers</em> in <a href="https://www.unicode.org/versions/Unicode15.0.0/ch09.pdf">Section 9.2</a> and <em>Prepended Concatenation Marks</em> in <a href="https://www.unicode.org/versions/Unicode15.0.0/ch23.pdf">Section 23.2</a> of The Unicode Standard.</p>
    <h2 id="historical-complications">Historical complications:</h2>
    <p>Due to Unicode history, the OpenType font logic for such spanning signs is slightly more complex than it otherwise would be. For details of the problem see <a href="https://www.unicode.org/cgi-bin/GetMatchingDocs.pl?L2/06-332">this proposal</a>, but in essence:</p>
    <ul>
    <li>Prior to Unicode 5.1 the spanning signs could end up in a different directional run from the digits that followed, in some cases making the order appear backwards (visually the digits were left of the sign) and font implementation difficult.</li>
    <li>Starting in Unicode 5.1 the spanning signs were changed from Bidirectional_Class=AL to AN. This has the effect of putting the sign and the digit sequence in the same directional run, making them easier to implement correctly.</li>
    </ul>
    <p>The upshot of this is that even today various implementations work differently, and as a result the logic inside fonts has to be smart enough to <em>work with either order</em>, i.e. when the sign precedes digits or when it follows digits.</p>
    <p>As a further result of these variations, OpenType font logic cannot use either <em>mark attachment</em> or <em>cursive attachment</em> lookups to reliably position digits upon spanning signs – the only reliable way we’ve found is through contextual single adjustment lookups.</p>
    <h1 id="sil-implementation">SIL Implementation</h1>
    <p><em>NB: Some of the information and basic OpenType techniques described hearin were learned by studying the <a href="https://github.com/aliftype/amiri/blob/main/sources/enclosing.fea">Amiri font feature code</a>.</em></p>
    <h2 id="digit-design">Digit design</h2>
    <p>The normal glyphs for digits are too large to be displayed with spanning signs, so we have smaller versions of all numeric digits that are to be so used. In fact for most of our fonts we have <em>two</em> smaller sizes of digits:</p>
    <ul>
    <li>Medium digits are used in all cases for most of the spanning signs.</li>
    <li>Small digits are used
    <ul>
    <li>for the Disputed End of Ayah sign or</li>
    <li>if there are 3 digits to be enclosed in an End of Ayah, thus allowing the End of Ayah to retain the same shape no matter whether there are 1, 2 or 3 digits following it.</li>
    </ul></li>
    </ul>
    <p>The exceptions to the need for two smaller sizes are Alkalami and Ruwudu fonts. These use different widths of End of Ayah for different numbers of digits, and thus these fonts require only one smaller size of digits.</p>
    <p>Because of the need to visually center the digits within End of Ayah, we utilize mono-width designs for all medium and small digits.</p>
    <p>In summary: for all three sets of digits (European digits, ARABIC-INDIC digits and with EXTENDED ARABIC-INDIC digits) and any language specific variants of those digits, we need one (or possibly two) sets of smaller digit glyphs. Within each of those sets, all digits must have the same width.</p>
    <h2 id="spanning-sign-design">Spanning sign design</h2>
    <p>For reference, here are the spanning signs, the default glyph name used in SIL fonts, and a repeat of the number of digits we want to support:</p>
    <table>
    <thead>
    <tr class="header">
    <th>Spanning Sign</th>
    <th>SIL default glyph name</th>
    <th>Max # digits</th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td>U+0600 ARABIC NUMBER SIGN</td>
    <td>number-ar</td>
    <td>3</td>
    </tr>
    <tr class="even">
    <td>U+0601 ARABIC SIGN SANAH</td>
    <td>year-ar</td>
    <td>4</td>
    </tr>
    <tr class="odd">
    <td>U+0602 ARABIC FOOTNOTE MARKER</td>
    <td>footnotemarker-ar</td>
    <td>2</td>
    </tr>
    <tr class="even">
    <td>U+0603 ARABIC SIGN SAFHA</td>
    <td>pagenumber-ar</td>
    <td>4</td>
    </tr>
    <tr class="odd">
    <td>U+0604 ARABIC SIGN SAMVAT</td>
    <td>samvat-ar</td>
    <td>4</td>
    </tr>
    <tr class="even">
    <td>U+0605 ARABIC NUMBER MARK ABOVE</td>
    <td>numbermark-ar</td>
    <td>4</td>
    </tr>
    <tr class="odd">
    <td>U+06DD ARABIC END OF AYAH</td>
    <td>endofayah-ar</td>
    <td>3</td>
    </tr>
    <tr class="even">
    <td>U+0890 ARABIC POUND MARK ABOVE</td>
    <td>poundmarkabove-ar</td>
    <td>4</td>
    </tr>
    <tr class="odd">
    <td>U+0891 ARABIC PIASTRE MARK ABOVE</td>
    <td>piastremarkabove-ar</td>
    <td>4</td>
    </tr>
    <tr class="even">
    <td>U+08E2 ARABIC DISPUTED END OF AYAH</td>
    <td>endofayahdisputed-ar</td>
    <td>3</td>
    </tr>
    </tbody>
    </table>
    <p>Here is an example using the U+065 Number Mark Above:</p>
    <p><img src="assets/images/numbermark_glyphs.png" alt="number mark alternates" /> <!-- PRODUCT SITE IMAGE SRC https://software.sil.org/arabicfonts/wp-content/uploads/sites/28/2016/06/numbermark_glyphs.png --></p>
    <p>We use <code>.2</code>, <code>.3</code>, and <code>.4</code> suffixes on sign glyph names to indicate how many digits a given glyph is designed to take. For example:</p>
    <ul>
    <li><code>numbermark-ar</code> is designed for one digit</li>
    <li><code>numbermark-ar.2</code> is designed for two digits</li>
    <li><code>numbermark-ar.3</code> is designed for three digits</li>
    </ul>
    <p>etc.</p>
    <p>One thing this does for in our workflow is automatically create some potentially useful FEA classes:</p>
    <ul>
    <li><code>c_2</code> class of all glyphs with <code>.2</code> extension</li>
    <li><code>cno_2</code> corresponding class of glyphs without the <code>.2</code> extension</li>
    <li><code>c_3</code> class of all glyphs with <code>.3</code> extension</li>
    <li><code>cno_3</code> corresponding class of glyphs without the <code>.3</code> extension</li>
    </ul>
    <p>etc.</p>
    <h2 id="anchors">Anchors</h2>
    <p>Anchors are defined to help position the digits to the spanning signs:</p>
    <p><img src="assets/images/numbermark_digits.png" alt="numbermark and digit anchors" /> <!-- PRODUCT SITE IMAGE SRC https://software.sil.org/arabicfonts/wp-content/uploads/sites/28/2016/06/numbermark_digits.png --></p>
    <ul>
    <li>Digit glyphs have <code>digitL</code> (left side) and <code>digitR</code> (right side) anchors at the baseline to attach each digit to the previous one</li>
    <li>Sign glyphs contain just the <code>digitR</code> anchor to define where the left-most of the digit sequence should be positioned</li>
    </ul>
    <p>As mentioned above, in most of our fonts the End of Ayah glyph doesn’t change width like the other spanning signs, but multiple glyph variants are still needed. This is because the <em>position</em> of the first digit depends on how many digits there are. This is further complicated in some of our fonts by the fact that the 1- and 2-digit versions of the glyph use the <em>medium</em> size digits, while the 3-digit version uses the <em>small</em> size digits in order to fit all of them in:</p>
    <p><img src="assets/images/end_of_ayah_glyphs.png" alt="endofayah-ar, endofayah-ar.2 and endofayah-ar.3" /> <!-- PRODUCT SITE IMAGE SRC https://software.sil.org/arabicfonts/wp-content/uploads/sites/28/2016/06/end_of_ayah_glyphs.png --></p>
    <h2 id="font-logic">Font logic</h2>
    <p>For simplicity, code snippets below implement just 4 spanning signs:</p>
    <ul>
    <li><code>numbermark-ar</code> at most 4 digits</li>
    <li><code>number-ar</code> at most 3 digits</li>
    <li><code>endofayah-ar</code> at most 3 digits</li>
    <li><code>footnotemarker-ar</code> at most 2 digits</li>
    </ul>
    <p>Both substitution and positioning rules are needed:</p>
    <ul>
    <li>Substitute the correct spanning sign glyph based on how many digits follow</li>
    <li>Substitute the medium or small digit glyphs for the normal-sized digit glyphs</li>
    <li>Adjust position of digits by attaching or aligning <code>digitL</code> to <code>digitR</code> anchors</li>
    </ul>
    <h3 id="graphite-logic">Graphite logic</h3>
    <p>The graphite rules are relatively straightforward attachments using the <code>digitL</code> and <code>digitR</code> anchors, but of course have to be done in both orders. Details are left to the reader.</p>
    <h3 id="opentype-logic">OpenType logic</h3>
    <p>It would be nice if we could use <em>anchor</em> or <em>cursive</em> attachment rules (GPOS lookup types 4 or 3) for positioning digits on spanning signs but this doesn't work — at least it can only work in one of the needed orders. Rather than any attachment rules, we use FEAX to construct the adjustment rules to kern the digits to the correct position on the spanning signs.</p>
    <h4 id="opentype-substitutions">OpenType substitutions</h4>
    <p>Substituting the correct sign glyph (based on how many digits follow) and substituting the correct size digits (medium or small) can be done in a single contextual rule.</p>
    <p>We start by making utility lookups that replace the spanning sign glyphs:</p>
    <pre><code>    lookup _signWith_4digits {   # Replace spanning signs with 4-digit variant
      lookupflag IgnoreMarks ;
        sub @cno_4 by @c_4 ;
    } _signWith_4digits ;
    
    lookup _signWith_3digits {   # Replace spanning signs with 3-digit variant
      lookupflag IgnoreMarks ;
        sub @cno_3 by @c_3 ;
    } _signWith_3digits ;
    
    lookup _signWith_2digits {   # Replace spanning signs with 2-digit variant
      lookupflag IgnoreMarks ;
        sub @cno_2 by @c_2 ;
    } _signWith_2digits ;</code></pre>
    <p>noting that we don't need a lookup for the 1-digit case because the default glyph for each spanning sign is constructed to handle the 1-digit case.</p>
    <p>Then we add utility lookups to substitute the digits:</p>
    <pre><code>    lookup _signDigits_ToMedium {  # replace digits with medium
      lookupflag IgnoreMarks ;
        sub @DigitsAny by @DigitsAnyMedium ;
    } _signDigits_ToMedium ;
    
    lookup _signDigits_ToSmall {  # replace digits with small
      lookupflag IgnoreMarks ;
        sub @DigitsAny by @DigitsAnysmall ;
    } _signDigits_ToSmall ;</code></pre>
    <p>And now, remembering that we have to handle different numbers of digits in both orders, we write contextual substitution rules that reference the utility lookups.</p>
    <pre><code>    lookup SignWithDigits {
      lookupflag IgnoreMarks ;
    
      # Uniscribe or HarfBuzz &#39;latn&#39; order: sign is before the digits
    
        # Handle spanning sign followed by 4 medium digits
        sub @c_4&#39; lookup _signWith_4digits 
            @DigitsAny&#39; lookup _signDigits_ToMedium 
            @DigitsAny&#39; lookup _signDigits_ToMedium 
            @DigitsAny&#39; lookup _signDigits_ToMedium 
            @DigitsAny&#39; lookup _signDigits_ToMedium ;
    
        # Handle spanning sign (other than End of Ayah) followed by 3 medium digits
        # class of sign glyphs has to be written out explicity because 
        # End of Ayah with 3 digits takes small digits. 
        # Note that footnotemarker-ar takes a max of 2 digits so also isn&#39;t included
        sub [ numbermark-ar number-ar ]&#39; lookup _signWith_3digits 
            @DigitsAny&#39; lookup _signDigits_ToMedium
            @DigitsAny&#39; lookup _signDigits_ToMedium
            @DigitsAny&#39; lookup _signDigits_ToMedium ;
    
        # Handle End of Ayah followed by 3 small digits
        sub endofayah-ar&#39; lookup _signWith_3digits 
            @DigitsAny&#39; lookup _signDigits_ToSmall
            @DigitsAny&#39; lookup _signDigits_ToSmall
            @DigitsAny&#39; lookup _signDigits_ToSmall ;
    
        # Handle spanning sign followed by 2 medium digits
        sub @c_2&#39; lookup _signWith_2digits 
            @DigitsAny&#39; lookup _signDigits_ToMedium
            @DigitsAny&#39; lookup _signDigits_ToMedium ;
    
        # Handle spanning sign followed by 1 medium digit
        sub @cno_2  
            @DigitsAny&#39; lookup _signDigits_ToMedium ;
    
      # HarfBuzz &#39;arab&#39; order: sign is after the digits
    
        # Handle 4 medium digits followed by spanning sign
        sub @DigitsAny&#39; lookup _signDigits_ToMedium
            @DigitsAny&#39; lookup _signDigits_ToMedium
            @DigitsAny&#39; lookup _signDigits_ToMedium
            @DigitsAny&#39; lookup _signDigits_ToMedium
            @c_4&#39; lookup _signWith_4digits ;
    
        # Handle 3 medium digits followed by spanning sign other than End of Ayah
        sub @DigitsAny&#39; lookup _signDigits_ToMedium
            @DigitsAny&#39; lookup _signDigits_ToMedium 
            @DigitsAny&#39; lookup _signDigits_ToMedium
            [ numbermark-ar number-ar ]&#39; lookup _signWith_3digits ;
    
        # Handle 3 small digits followed by End of Ayah
        sub @DigitsAny&#39; lookup _signDigits_ToSmall
            @DigitsAny&#39; lookup _signDigits_ToSmall 
            @DigitsAny&#39; lookup _signDigits_ToSmall
            endofayah-ar&#39; lookup _signWith_3digits ;
    
        # Handle 2 medium digits followed by spanning sign
        sub @DigitsAny&#39; lookup _signDigits_ToMedium
            @DigitsAny&#39; lookup _signDigits_ToMedium
            @c_2&#39; lookup _signWith_2digits ;
    
        # Handle 1 medium digit followed by spanning sign
        sub @DigitsAny&#39; lookup _signDigits_ToMedium
            @cno_2 ;
    
    } SignWithDigits ;</code></pre>
    <h4 id="opentype-positioning">OpenType positioning</h4>
    <p>Some assumptions:</p>
    <ul>
    <li>for all the digits, the <code>digitL</code> and <code>digitR</code> APs are positioned at the same height and exactly on the sidebearings (this simplifies the math somewhat).</li>
    <li>all the medium digits have the same width and anchors, and similarly for the small digits if used. This means it doesn't matter which particular medium digit or small digit we use for calculations — we've chosen <code>zero.medium</code> and <code>zero.small</code></li>
    <li>in our FEAX code, we let:
    <ul>
    <li><code>m</code> represent the spanning sign glyph</li>
    <li><code>w</code> represent the the <em>negative</em> of the width of the digits, which can be calculated in FEAX using, for example:</li>
    </ul>
    <pre><code>    let w = -ADVx(&quot;zero.medium&quot;) ;</code></pre></li>
    </ul>
    <p>(For more information about the extensions of the FEA syntax used in this code, see <a href="https://github.com/silnrsi/pysilfont/blob/master/docs/feaextensions.html#do">fea extensions do statement</a>.)</p>
    <p>We do <em>not</em> assume that the spanning signs have their <code>digitR</code> anchors at the same height as the anchors of the digits, so we'll calculate a vertical kerning as well.</p>
    <p>For the first example, we'll use a 3-digit sequence:</p>
    <p><img src="assets/images/numbermark_digits.png" alt="numbermark and digits" /> <!-- PRODUCT SITE IMAGE SRC https://software.sil.org/arabicfonts/wp-content/uploads/sites/28/2016/06/numbermark_digits.png --></p>
    <p>Step one is to align first digit's <code>digitL</code> anchor with the sign glyph's <code>digitR</code>. To do this, calculate the offsets (x and y) from the digit's starting position to where we want it positioned. The first digit's starting position will be on the baseline immediately to the right of the spanning sign glyph, in other words the digit's left sidebearing will align with the spanning sign's right sidebearing.</p>
    <p>The amount the digit needs to be moved vertically to align its anchor to that of the spanning sign is the difference in the y coordinates of the anchors. In FEAX we can calculate that using:</p>
    <pre><code>    let y = APy(m, &quot;digitR&quot;) - APy(&quot;zero.medium&quot;, &quot;digitL&quot;);</code></pre>
    <p>Horizontally we need to left-kern that first digit a distance equal to the width of the spanning sign minus the x-coordinate of the spanning sign's <code>digitR</code> anchor. Since a left-kern is negative, in FEAX we calculate the value and save it in a variable <code>x1</code> by:</p>
    <pre><code>    let x1 = APx(m, &quot;digitR&quot;) - ADVx(m);</code></pre>
    <p>At the same time we kern the first digit, we want to remove its advancewidth. Thus we start out our contextual kerning rule using:</p>
    <pre><code>    pos $m  @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt; @DigitsAnyMedium&#39; @DigitsAnyMedium&#39; DigitsAnyMedium&#39;;</code></pre>
    <p>(For refresher on the <code>&lt;...&gt;</code> value record, see <a href="https://github.com/adobe-type-tools/afdko/blob/develop/docs/OpenTypeFeatureFileSpecification.html#value-record-format-b">Value record format B</a> in the Adobe FEA specification.)</p>
    <p>Considering the second digit, we want to move it from its starting position to a position immediately right of the first digit. Again we need to know the starting position of the second digit and this may surprise the reader. Because we removed the advance width of the first digit when we kerned it, the starting position of the second digit is the same as that of the first digit (before we moved it): immediately right of the spanning sign glyph. The kern distance for the second digit is, therefore, the same as that of the first but to the right by the width of the first digit. Because <code>w</code> is negative, we calculate the second digit's kern in FEAX as:</p>
    <pre><code>    let x2 = x1 - w;</code></pre>
    <p>We can now add kerning for the second digit to our existing rule:</p>
    <pre><code>    pos $m  @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt; @DigitsAnyMedium&#39; &lt;$x2 $y $w 0&gt; DigitsAnyMedium&#39; ;</code></pre>
    <p>Adding similar logic for the 3rd digit and putting it all together gives us this snippet for a 3-digit sequence for a sign <code>m</code>:</p>
    <pre><code>    let y = APy(m, &quot;digitR&quot;) - APy(&quot;zero.medium&quot;, &quot;digitL&quot;);
    let w = -ADVx(d); 
    let x1 = APx(m, &quot;digitR&quot;) - ADVx(m); 
    let x2 = x1 - w; 
    let x3 = x2 - w;</code></pre>
    <p>with positioning rules</p>
    <pre><code>    pos $m  @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt; @DigitsAnyMedium&#39; &lt;$x2 $y $w 0&gt;  DigitsAnyMedium&#39; &lt;$x3 $y $w 0&gt; ;
    pos     @DigitsAnyMedium&#39; &lt;$x3 $y $w 0&gt; @DigitsAnyMedium&#39; &lt;$x2 $y $w 0&gt;  @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt; $m ;</code></pre>
    <p>Note that we've added a second positioning rule to handle the case where the spanning sign <em>follows</em> the digits — confirming it is correct is an exercise for the reader.</p>
    <p>One last step is to put all this together with some FEAX that iterates through the spanning signs. For the limited example of the four spanning signs, the complete set of positioning rules would look something like:</p>
    <pre><code>    lookup PositionSpanningSigns {
      lookupflag IgnoreMarks ;
          # In each &quot;do&quot; template, the first rule is ordered for Uniscribe or HarfBuzz &#39;latn&#39;, the second for HarfBuzz &#39;arab&#39;
    
        # Those that take 4 medium digits
        do for m = @c_4 ;
           let y = APy(m, &quot;digitR&quot;) - APy(&quot;zero.medium&quot;, &quot;digitL&quot;);
           let w = -ADVx(&quot;zero.medium&quot;); 
           let x1 = APx(m, &quot;digitR&quot;) - ADVx(m); 
           let x2 = x1 - w; let x3 = x2 - w; let x4 = x3 - w;
        {
            pos $m  @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt; @DigitsAnyMedium&#39; &lt;$x2 $y $w 0&gt;  @DigitsAnyMedium&#39; &lt;$x3 $y $w 0&gt;  @DigitsAnyMedium&#39; &lt;$x4 $y $w 0&gt; ;
            pos     @DigitsAnyMedium&#39; &lt;$x4 $y $w 0&gt; @DigitsAnyMedium&#39; &lt;$x3 $y $w 0&gt;  @DigitsAnyMedium&#39; &lt;$x2 $y $w 0&gt;  @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt; $m ;
        }
        
        # Those that take 3 medium digits
        do for m = [ number-ar.3 numbermark-ar.3 ] ;
           let y = APy(m, &quot;digitR&quot;) - APy(&quot;zero.medium&quot;, &quot;digitL&quot;);
           let w = -ADVx(&quot;zero.medium&quot;); 
           let x1 = APx(m, &quot;digitR&quot;) - ADVx(m); 
           let x2 = x1 - w; let x3 = x2 - w;
        {
            pos $m  @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt;  @DigitsAnyMedium&#39; &lt;$x2 $y $w 0&gt;  @DigitsAnyMedium&#39; &lt;$x3 $y $w 0&gt; ;
            pos     @DigitsAnyMedium&#39; &lt;$x3 $y $w 0&gt;  @DigitsAnyMedium&#39; &lt;$x2 $y $w 0&gt;  @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt;  $m ;
        }
    
        # Those that take 3 small digits (default for @c_3)
        do for m = [ endofayah-ar.3 ] ;
           let y = APy(m, &quot;digitR&quot;) - APy(&quot;zero.small&quot;, &quot;digitL&quot;);
           let w = -ADVx(&quot;zero.small&quot;); 
           let x1 = APx(m, &quot;digitR&quot;) - ADVx(m); 
           let x2 = x1 - w; let x3 = x2 - w;
        {
            pos $m  @DigitsAnySmall&#39; &lt;$x1 $y $w 0&gt;  @DigitsAnySmall&#39; &lt;$x2 $y $w 0&gt;  @DigitsAnySmall&#39; &lt;$x3 $y $w 0&gt; ;
            pos     @DigitsAnySmall&#39; &lt;$x3 $y $w 0&gt;  @DigitsAnySmall&#39; &lt;$x2 $y $w 0&gt;  @DigitsAnySmall&#39; &lt;$x1 $y $w 0&gt;  $m ;
        }
    
        # Those that take 2 medium digits
        do for m = @c_2 ;
           let y = APy(m, &quot;digitR&quot;) - APy(&quot;zero.medium&quot;, &quot;digitL&quot;);
           let w = -ADVx(&quot;zero.medium&quot;); 
           let x1 = APx(m, &quot;digitR&quot;) - ADVx(m); 
           let x2 = x1 - w; 
        {
            pos $m  @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt;  @DigitsAnyMedium&#39; &lt;$x2 $y $w 0&gt; ;
            pos     @DigitsAnyMedium&#39; &lt;$x2 $y $w 0&gt;  @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt;  $m ;
        }
        
        # Those that take 1 medium digit
        do for m = @cno_2 ;
           let y = APy(m, &quot;digitR&quot;) - APy(&quot;zero.medium&quot;, &quot;digitL&quot;);
           let w = -ADVx(&quot;zero.medium&quot;); 
           let x1 = APx(m, &quot;digitR&quot;) - ADVx(m); 
        {
            pos $m @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt; ;
            pos    @DigitsAnyMedium&#39; &lt;$x1 $y $w 0&gt; $m ;
        }
    } PositionSpanningSigns ;</code></pre>
    <p>Because of variation in the repertoire of signs supported and their specific designs, actual implementation in our fonts will vary in the details but the principals are the same.</p>
    <h2 id="postscript">Postscript</h2>
    <p>The observant reader will have noted that the <code>DigitR</code> anchor on digit glyphs is not actually used in the code. However it is used in Graphite code which was not covered in this document.</p>
    <footer class="footer">
        <p>This guide is from the <a href="https://github.com/silnrsi/font-arab-tools" title="" class="active">font-arab-tools project</a> and is copyright © 2022-2023 SIL International.</p>
    </footer>
</article>
</div>
</body>
</html>